---
title: "Exploratory Data Analysis"
author: "Madalyn Young and Imogen Holdsworth"
date: "2025-04-09"
output: 
  html_document:
    number_sections: yes
    toc: yes
    toc_float: yes # makes the toc move along
    code_folding: "hide"  # Use "hide" to collapse code by default
editor_options: 
  chunk_output_type: inline
---

```{r load packages, include = FALSE}

pacman::p_load(tidyverse, scales, dplyr, corrr, janitor, tidyr, psych, readr, lubridate, rpart, rpart.plot, caret, C50, sf, maps, dbscan, geosphere, nnet, randomForest,readxl, tsibble, ggplot2, forecast, tseries, lme4, performance, yardstick, purr,lmerTest)
```

# Introduction

Swire Coca-Cola is the Coca-Cola distributor for 13 states on the west coast. They service two customer groups -  red truck customers, which are local businesses Swire services through its in-house logistics system, and white truck customers – which are larger distributors that buy and sell Coca-Cola to another end customer. Swire wants to understand and segment the red truck customer group in order to identify which customers they should keep internally servicing.
The purpose of the project is to identify customers that Swire currently works with that are or will be ordering above/below the threshold set at 400 gallons a year. The project will include developing a model to predict which customers are anticipated to grow above threshold, and include analysis on characteristics of profitable red truck customers.


Analysis should include two groups:
- Local Market Partners: Customers who buy only fountain drinks and no CO2, no cans and no bottles.
- All Customers: Including those who may buy fountain drinks, CO2, cans, bottles, or any combination of these.

Data Sources: Historical sales data, Customer profiles,Delivery Costs

The purpose of this notebook is to explore the data provided by SWIRE to start identifying important variables that will help us eventually predict customer orders as well as simply give us a better understanding of SWIRES customer base and business operations 

# Original Data

## Customer Profile Data

This dataset provides the details information about customer orders including the onboarding and customer behavior information. 
```{r cust profile}
CustomerProfileData <- read.csv("Data/customer_profile.csv")  


colSums(is.na(CustomerProfileData))

  #PRIMARY_GROUP_NUMBER  missing 18196

summary(CustomerProfileData)
```

***Profile Dictionary:*** 
CUSTOMER_NUMBER: Unique identifier for each outlet/store
PRIMARY_GROUP_NUMBER :A unique identifier for each retailer. Multiple customer_numbers (outlets) belonging to the same primary_group (retailer) indicate they are part of a chain.
FREQUENT_ORDER_TYPE: Most common type of order placed by the customer (e.g., "MYCOKE LEGACY", "SALES REP").
FIRST_DELIVERY_DATE: Date of the first delivery to the customer.
ON_BOARDING_DATE: Date the customer was onboarded.
COLD_DRINK_CHANNEL: General channel category for cold drink purchases (e.g., "DINING").
TRADE_CHANNEL: Detailed channel classification (e.g., "OTHER DINING & BEVERAGE").
SUB_TRADE_CHANNEL: Sub-classification within the trade channel (e.g., "OTHER DINING").
LOCAL_MARKET_PARTNER: Boolean indicating if the customer is a local market partner (True/False).
CO2_CUSTOMER: Boolean indicating if the customer purchases CO2 products (True/False).
ZIP_CODE: ZIP code associated with the customer.

Ordering Types:
MYCOKE LEGACY: Old digital ordering platform.
EDI: Orders places via Electronic Data Interchange, bottler sales data is fed directly into retailer system which generates payments to bottlers.
CALL CENTER: Customer places orders via call center.
SALES REP: Sales representative enters customer orders.
MYCOKE 360: New digital ordering platform launched in summer 2024.
OTHER: Less common methods of ordering.

*MyCoke 360 replaced the legacy MyCoke platform to provide an improved, modernized digital ordering experience.

***Notes:***

The only missing data in this dataset is the Primary Group Number, now this data is not really 'missing' some customers just do not operate as part of an outlet or chain so they do not have the primary group number that will indicate a unique retailer, as the customer number is their unique indicator. This 'missing' data will be addressed when we join the transnational data and re-aggregate. 

## Transaction Data
This dataset records detailed transnational information, including order quantities and delivery metrics.
```{r Transactional Data}
TransactionalData <- read.csv("Data/transactional_data.csv")


colSums(is.na(TransactionalData))
  # no missing data

summary(TransactionalData)
```

***Transaction Data Dictionary***
TRANSACTION_DATE: Date of the transaction (YYYY-MM-DD format).
WEEK: Week number of the year when the transaction occurred.
YEAR: Year of the transaction.
CUSTOMER_NUMBER: Unique identifier for the customer.
ORDER_TYPE: Type of order placed (e.g., "SALES REP", "MYCOKE LEGACY").
ORDERED_CASES: Number of cases ordered by the customer.
LOADED_CASES: Number of cases loaded for delivery.
DELIVERED_CASES: Number of cases delivered to the customer.
ORDERED_GALLONS: Number of gallons ordered by the customer.
LOADED_GALLONS: Number of gallons loaded for delivery.
DELIVERED_GALLONS: Number of gallons delivered to the customer.

***Notes***
* Gallons and cases have been converted to the same unit of measure. One Gallon = One Case
* See cases where ordered volume is 0 and the delivered or loaded is more than 0. Issues in lead times?
- data is aggregated by transaction date not by order, therefore each row might not belong to the same order 


## Location Data
```{r address data}
AddressZipData <- read.csv("Data/customer_address_and_zip_mapping.csv")
```
The address data will need to reformatted with the correct column structure in order to complete analysis by City, Zip or Streets.

```{r}
#clean the address data
# Split the column
AddressZipData <- AddressZipData |>
  separate(full.address, into = c("ZIP", "City", "State Name", "State Short", 
                                  "County","Code", "Latitude", "Longitude"), sep = ",")

AddressZipData$Latitude <- as.numeric(AddressZipData$Latitude)

AddressZipData$Longitude <- as.numeric(AddressZipData$Longitude)
```

The Customer Address and ZIP dataset maps ZIP codes to full address information, this location information can be used in conjunction with the Customer Profile dataset to understand the location and geographical distribution of customers that SWIRE works with.


This dataset maps ZIP codes to full address information.

## Delivery Cost Data

```{r cost data}
DeliveryCostData <- read.csv("Data/delivery_cost_data.csv")
```

```{r}
colSums(is.na(DeliveryCostData))
  # no missing data

summary(DeliveryCostData)
```


#Data Cleaning and Aggragation


```{r}
TransactionalData$TRANSACTION_DATE <- mdy(TransactionalData$TRANSACTION_DATE)
  

TransactionalData <- TransactionalData %>% 
  mutate(Quarter_column = quarter(TRANSACTION_DATE), 
         Quarter_year = paste(Quarter_column, YEAR, sep = " "),
         MONTH = month(TRANSACTION_DATE)) %>% 
  select(-c(LOADED_CASES, DELIVERED_CASES, LOADED_GALLONS, DELIVERED_GALLONS))
```

## Customer Profile Data Cleaning

* Added Entity ID to look at customers with outlet all together
* clean date format
* convert character columns to factors
* convert logical columns to 0/1 - for easier modeling later
* filter out the one customer that has a first delivery date before they were on boarded
```{r}
#clean Customer Profile Data
  CustomerProfileData <-  CustomerProfileData %>% 
  mutate(
    Entity_ID = case_when(
      is.na(PRIMARY_GROUP_NUMBER) ~ CUSTOMER_NUMBER,  # If PRIMARY_GROUP_NUMBER is NA, use CUSTOMER_NUMBER
      TRUE ~ PRIMARY_GROUP_NUMBER),
    ON_BOARDING_DATE = mdy(ON_BOARDING_DATE),
    FIRST_DELIVERY_DATE = mdy(FIRST_DELIVERY_DATE),
    ON_BOARDING_YEAR = year(ON_BOARDING_DATE),
    FIRST_DELIVERY_YEAR = year(FIRST_DELIVERY_DATE))

char_col <- sapply(CustomerProfileData, is.character)
CustomerProfileData[char_col] <- lapply(CustomerProfileData[char_col], as.factor)

logical_cols <- sapply(CustomerProfileData, is.logical)
CustomerProfileData[logical_cols] <- lapply(CustomerProfileData[logical_cols], as.numeric)

#remove the customer where their on_boarding date was first delivery date was before the onboarding date (1 customer)
CustomerProfileData <- CustomerProfileData %>% 
  filter(FIRST_DELIVERY_DATE>=ON_BOARDING_DATE)
```


## Annual Aggregated Transactionl Data

```{r}
#Pivot wide the cost data
#aggregated  transaction data to join to customer table

# aggregate transaction data by customer_number and year
#sum the ordered cases and gallons by customer number and year
#this table is set up so each customer number has  two rows, one for 2023, one for 2024. Each column is sum of ordered cases/loaded cases. delivered cases in that year 
aggregated_cost <- TransactionalData |>
  group_by(CUSTOMER_NUMBER, YEAR) |>
  summarize(orderedCases = sum(ORDERED_CASES),
            orderedGallons = sum(ORDERED_GALLONS))



#The code pivots the database above to have one row per customer and a column for each cases/gallons ordered for each year
aggregated_cost_wide <- aggregated_cost |>
  pivot_wider(
    names_from = YEAR, 
    values_from = c(orderedCases, 
                    orderedGallons),
    names_sep = "_"
  )
```

## Location Clustering

```{r}
CustomerProfile_Location <- CustomerProfileData %>% 
  left_join(AddressZipData, by = c("ZIP_CODE"="zip")) 
```

* do KMeans clustering to identify the four main location clusters
* identify the center (Centroid) of each of the four main clusters
```{r}
#cluster the addresses and calculate the centroid for each cluster
##Multiple centroids
set.seed(123)

kmeans_result <- kmeans(CustomerProfile_Location[,c("Longitude", "Latitude")], centers = 4)

CustomerProfile_Location$cluster <- as.factor(kmeans_result$cluster)


centroids <- CustomerProfile_Location %>% 
  group_by(cluster) %>% 
  summarize(centroid_lon = mean(Longitude), centroid_lat = mean(Latitude))

```


* Calculate the miles distance of each customers location to the centroid
```{r}

haversine_distance <- function(lon1, lat1, lon2, lat2) {
  distHaversine(c(lon1, lat1), c(lon2,lat2))/1609.34 
}# converts meters to miles

#Join main customer data to the clusters created above
CustomerProfile_Location <- CustomerProfile_Location %>% 
  left_join(centroids, by = "cluster")


CustomerProfile_Location <- CustomerProfile_Location %>% 
  mutate(
    distance_to_centroid = mapply(haversine_distance, CustomerProfile_Location$Longitude, CustomerProfile_Location$Latitude, CustomerProfile_Location$centroid_lon, CustomerProfile_Location$centroid_lat)
  )

```


## Full Aggregated Dataset
```{r}
Annual_Customer_ALL <-  CustomerProfile_Location %>% 
  left_join(aggregated_cost_wide, by = "CUSTOMER_NUMBER") %>% 
  mutate(across(c(orderedCases_2023, orderedCases_2024, orderedGallons_2023, orderedGallons_2024), ~ replace_na(.x, 0)),
         total_ordered = (orderedCases_2024 + orderedGallons_2024 +orderedCases_2023 + orderedGallons_2023),
         total_ordered_2023 = (orderedCases_2023 + orderedGallons_2023),
         total_ordered_2024 = (orderedCases_2024 + orderedGallons_2024)) %>% 
  filter(!(year(FIRST_DELIVERY_DATE) == 2023 & orderedCases_2023 == 0 & orderedGallons_2023 == 0) &
    !(year(FIRST_DELIVERY_DATE) == 2024 & orderedCases_2024 == 0 & orderedGallons_2024 == 0))
```

```{r}
Annual_Customer_ALL <- Annual_Customer_ALL %>% 
  group_by(Entity_ID) %>% 
    mutate(across(c(orderedCases_2023, orderedCases_2024, orderedGallons_2023, orderedGallons_2024), ~ replace_na(.x, 0)),
         total_ordered = (orderedCases_2024 + orderedGallons_2024 +orderedCases_2023 + orderedGallons_2023),
         total_ordered_2023 = (orderedCases_2023 + orderedGallons_2023),
         total_ordered_2024 = (orderedCases_2024 + orderedGallons_2024)) %>% 
  group_by(Entity_ID) %>% 
  summarize(FREQUENT_ORDER_TYPE = FREQUENT_ORDER_TYPE[which.max(tabulate(match(FREQUENT_ORDER_TYPE, unique(FREQUENT_ORDER_TYPE))))],
            COLD_DRINK_CHANNEL = first(COLD_DRINK_CHANNEL),
            TRADE_CHANNEL = first(TRADE_CHANNEL),
            SUB_TRADE_CHANNEL = first(SUB_TRADE_CHANNEL),
            FIRST_DELIVERY_DATE = min(FIRST_DELIVERY_DATE),
            FIRST_DELIVERY_YEAR = min(FIRST_DELIVERY_YEAR),
            ON_BOARDING_DATE = min(ON_BOARDING_DATE),
            ON_BOARDING_YEAR = min(ON_BOARDING_YEAR),
            customer_age = as.numeric(format(Sys.Date(), "%Y")) - ON_BOARDING_YEAR,
            
            LOCAL_MARKET_PARTNER = LOCAL_MARKET_PARTNER[which.max(tabulate(match(LOCAL_MARKET_PARTNER,unique(LOCAL_MARKET_PARTNER))))],
            CO2_CUSTOMER =  CO2_CUSTOMER[which.max(tabulate(match(CO2_CUSTOMER, unique(CO2_CUSTOMER))))],
            hasOutlet = first(case_when(is.na(PRIMARY_GROUP_NUMBER)~ 0,TRUE ~1)),
            numberOfOutlets = sum(case_when(is.na(PRIMARY_GROUP_NUMBER)~ 1,TRUE ~1)),
            wellPerformingOutlet = sum(case_when((orderedGallons_2023 + orderedCases_2023) >= 400 ~ 1, (orderedGallons_2024 + orderedCases_2024) >=400 ~ 1, TRUE ~ 0)),
            
            hasOrderedCases = as.integer(mean(case_when((orderedCases_2023 + orderedCases_2024)>0 ~1, TRUE ~ 0))>0,1,TRUE~0),
            
            propCases = sum(orderedCases_2023, orderedCases_2024)/ sum(total_ordered),
            
            GeoSpread = n_distinct(ZIP),
            most_common_zip = if_else(
              numberOfOutlets == 1,  # If only one location, take that ZIP
              first(ZIP),
              ZIP[which.max(tabulate(match(ZIP, unique(ZIP))))]), 
            largest_zip = if_else(
              numberOfOutlets == 1,
              first(ZIP),
              ZIP[which.max(total_ordered)]
            ),
            
            most_common_city = if_else(
              numberOfOutlets == 1,  # If only one location, take that ZIP
              first(City),
              City[which.max(tabulate(match(City, unique(City))))]), 
            largest_city = if_else(
              numberOfOutlets == 1,
              first(City),
              City[which.max(total_ordered)]
            ),
            
            most_common_state = if_else(
              numberOfOutlets == 1,  # If only one location, take that ZIP
              first(`State Name`),
              `State Name`[which.max(tabulate(match(`State Name`, unique(`State Name`))))]), 
            largest_state = if_else(
              numberOfOutlets == 1,
              first(`State Name`),
              `State Name`[which.max(total_ordered)]
            ),
            
            most_common_region = if_else(
              numberOfOutlets == 1,  # If only one location, take that ZIP
              first(cluster),
              cluster[which.max(tabulate(match(cluster, unique(cluster))))]), 
            largest_region = if_else(
              numberOfOutlets == 1,
              first(cluster),
              cluster[which.max(total_ordered)]
            ),
            
            most_common_distance = if_else(
              numberOfOutlets == 1,  # If only one location, take that ZIP
              first(distance_to_centroid),
              distance_to_centroid[which.max(tabulate(match(distance_to_centroid, unique(distance_to_centroid))))]), 
            
            largest_distance = if_else(
              numberOfOutlets == 1,
              first(distance_to_centroid),
              distance_to_centroid[which.max(total_ordered)]
            ),
            
                        
            avg_distance = if_else(
              numberOfOutlets == 1,
              first(distance_to_centroid),
              mean(distance_to_centroid)
            ),
            

            total_ordered_2023 = sum(total_ordered_2023),
            total_ordered_2024 = sum(total_ordered_2024),
            percentChangeYOY = ((total_ordered_2024) - (total_ordered_2023))/(total_ordered_2023))%>% 
  mutate(Binning_column = case_when(
    (total_ordered_2023 < 400 & total_ordered_2024 < 400) & percentChangeYOY < 0.10 ~ "low volume low growth",
         (total_ordered_2023 < 400 & total_ordered_2024 < 400) & percentChangeYOY > 0.10 ~ "low volume high growth",
         (total_ordered_2023 > 400 & total_ordered_2024 > 400) & percentChangeYOY < 0.05 ~ "high volume low growth",
         (total_ordered_2023 > 400 & total_ordered_2024 > 400) & percentChangeYOY > 0.05 ~ "high volume high growth",
         (total_ordered_2023 >= 400 | total_ordered_2024 >= 400) & percentChangeYOY > 0 ~ "transtionary growing",
         (total_ordered_2023 >= 400 | total_ordered_2024 >= 400) & percentChangeYOY < 0 ~ "transitionary declining" ))

```

# Exploratory Visualizations and Tables

## Customer Order Understanding
```{r}
Annual_Customer_ALL %>% 
  filter((total_ordered_2023+total_ordered_2024)<=400) %>% 
ggplot(aes(x = (total_ordered_2023+total_ordered_2024))) +
  geom_density(fill = "lightblue", alpha = 0.6) +
  labs(title = "Density of Order Amounts",
       x = "Order Amount",
       y = "Density") +
  theme_minimal()
```
Of the customers that order below threshold many order between 0 and 100 gallons

Historgrams and densitiy plots do not pick up the largest customer orders well visually. Below is a table of the top largest customer 

```{r}
 Annual_Customer_ALL %>%
  mutate(total_ordered = total_ordered_2023 + total_ordered_2024) %>%
  filter(total_ordered > 400) %>%
  arrange(desc(total_ordered)) %>%
  slice_head(n = 10) %>%
  select(Entity_ID, total_ordered_2023, total_ordered_2024, total_ordered)
```

A lot of the high performers seem to be a retailer. The below graphs the number of outlets a customer has compared to the number of well performing outlets it has. Is a customer only well performing because it has many sub par performing outlets?

```{r}
Annual_Customer_ALL %>% 
  filter(hasOutlet == 1) %>% 
  ggplot(aes(x=numberOfOutlets, y = wellPerformingOutlet))+
  geom_point(color = "blue", size = 3)+
  geom_smooth(method = "lm", color = "red", se = TRUE) +
  theme_minimal()
```
Some Customers have a lot of outlets. We filtered out those outliers to see more clearly the trend 

```{r}
Annual_Customer_ALL %>% 
  filter((hasOutlet == 1) & (numberOfOutlets<=200)) %>% 
  ggplot(aes(x=numberOfOutlets, y = wellPerformingOutlet))+
  geom_point(color = "blue", size = 3)+
  geom_smooth(method = "lm", color = "red", se = TRUE) +
  theme_minimal()
```

The below graph helps us understand if on boarding year plays a role in volume. Do older or newer customers perform better?
```{r}
Annual_Customer_ALL %>%
  mutate(OnboardingYear = lubridate::year(ON_BOARDING_DATE),
         AboveThreshold = ifelse((total_ordered_2023+total_ordered_2024) >= 800, "Above", "Below")) %>%
  count(OnboardingYear, AboveThreshold) %>%
  group_by(OnboardingYear) %>%
  mutate(prop = n / sum(n)) %>%
  ggplot(aes(x = factor(OnboardingYear), y = prop, fill = AboveThreshold)) +
  geom_col(position = "fill") +
  scale_y_continuous(labels = scales::percent) +
  labs(title = "Proportion of Customers Above Threshold by Onboarding Year",
       x = "Onboarding Year",
       y = "Percentage",
       fill = "Threshold Status") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
  ##theme_minimal()
```

Lots of new customers are not well performing. However this could be due to a distribution of on boarding year:

```{r}

ggplot(Annual_Customer_ALL, aes(x = factor(ON_BOARDING_YEAR))) +
  geom_bar(fill = "steelblue") +
  labs(title = "Distribution of Onboarding Year",
       x = "Onboarding Year",
       y = "Count of Customers") +
  theme_minimal()
```
Most of the database are new customers. 



We see the majority of this data set are customers under performing as shown by the proportions below
```{r}
Annual_Customer_ALL %>%
  mutate(order_group = ifelse(total_ordered_2023 < 400 | total_ordered_2024 < 400, "<400", "400+")) %>%
  count(order_group) %>%
  mutate(proportion = n / sum(n))
```

```{r}
 Annual_Customer_ALL %>%
  filter(total_ordered_2023 == 0) %>%
  select(Entity_ID, total_ordered_2023, total_ordered_2024)
```
3K customers did not order in 2023, which means we see these customers as infinite growth YOY

We wanted to see if any time series modeling might be applicable. in order to do that we had to reaggregate the data

```{r}
aggregated_cost_by_month <- TransactionalData |>
  group_by(CUSTOMER_NUMBER, YEAR, Quarter_column, Quarter_year,MONTH) |>
  summarize(orderedCases = sum(ORDERED_CASES),
            orderedGallons = sum(ORDERED_GALLONS),
            totalOrdered = sum(ORDERED_CASES, ORDERED_GALLONS))
```


```{r}
UnaggregatedDates_Customer_No_Retailer <- CustomerProfile_Location %>% 
  left_join(aggregated_cost_by_month, by = "CUSTOMER_NUMBER") %>% 
   mutate(across(c(orderedCases, orderedGallons, totalOrdered), ~ replace_na(.x, 0))) 
  
```

*create rows for each month
```{r}
all_months <- crossing(
  CUSTOMER_NUMBER = unique(UnaggregatedDates_Customer_No_Retailer$CUSTOMER_NUMBER),
  YEAR = unique(UnaggregatedDates_Customer_No_Retailer$YEAR, na.rm = TRUE),
  MONTH = 1:12
) %>%
  mutate(
    Quarter_column = case_when(
      MONTH >= 1 & MONTH <= 3 ~ 1,
      MONTH >= 4 & MONTH <= 6 ~ 2,
      MONTH >= 7 & MONTH <= 9 ~ 3,
      TRUE ~ 4
    ),
    Quarter_year = paste(Quarter_column, YEAR, sep = " ")
  ) %>% filter(!is.na(YEAR) )

# First, create a customer reference dataset with one row per customer
customer_reference <- UnaggregatedDates_Customer_No_Retailer %>%
  group_by(CUSTOMER_NUMBER) %>%
  summarize(
    PRIMARY_GROUP_NUMBER = first(PRIMARY_GROUP_NUMBER),
    FREQUENT_ORDER_TYPE = first(FREQUENT_ORDER_TYPE),
    FIRST_DELIVERY_DATE = first(FIRST_DELIVERY_DATE),
    ON_BOARDING_DATE = first(ON_BOARDING_DATE),
    COLD_DRINK_CHANNEL = first(COLD_DRINK_CHANNEL),
    TRADE_CHANNEL = first(TRADE_CHANNEL),
    SUB_TRADE_CHANNEL = first(SUB_TRADE_CHANNEL),
    LOCAL_MARKET_PARTNER = first(LOCAL_MARKET_PARTNER),
    CO2_CUSTOMER = first(CO2_CUSTOMER),
    ZIP_CODE = first(ZIP_CODE),
    Entity_ID = first(Entity_ID),
    ON_BOARDING_YEAR = first(ON_BOARDING_YEAR),
    FIRST_DELIVERY_YEAR = first(FIRST_DELIVERY_YEAR),
    ZIP = first(ZIP),
    City = first(City),
    `State Name` = first(`State Name`),
    Latitude = first(Latitude),
    Longitude = first(Longitude),
    cluster = first(cluster),
    distance_to_centroid = first(distance_to_centroid)
  )

# Now join the transactions with all_months first, then join with customer reference

UnaggregatedDates_Customer_No_Retailer <- all_months %>%
  left_join(
    UnaggregatedDates_Customer_No_Retailer %>% 
      select(CUSTOMER_NUMBER, YEAR, MONTH, Quarter_column, Quarter_year, orderedCases, orderedGallons, totalOrdered),
    by = c("CUSTOMER_NUMBER", "YEAR", "MONTH")
  ) %>%
  mutate(across(c(orderedCases, orderedGallons, totalOrdered), ~ replace_na(.x, 0))) %>%
  # Join with the customer reference data
  left_join(customer_reference, by = "CUSTOMER_NUMBER")

```


```{r}
BYQUARTER_Customer_No_Retailer <- UnaggregatedDates_Customer_No_Retailer %>% 
  filter(is.na(PRIMARY_GROUP_NUMBER)) %>% 
  group_by(Entity_ID, Quarter_year.x) %>% 
  reframe(
    FREQUENT_ORDER_TYPE = FREQUENT_ORDER_TYPE[which.max(tabulate(match(FREQUENT_ORDER_TYPE, unique(FREQUENT_ORDER_TYPE))))],
    COLD_DRINK_CHANNEL = first(COLD_DRINK_CHANNEL),
    TRADE_CHANNEL = first(TRADE_CHANNEL),
    SUB_TRADE_CHANNEL = first(SUB_TRADE_CHANNEL),
    FIRST_DELIVERY_DATE = min(FIRST_DELIVERY_DATE),
    FIRST_DELIVERY_YEAR = min(FIRST_DELIVERY_YEAR),
    ON_BOARDING_DATE = min(ON_BOARDING_DATE),
    ON_BOARDING_YEAR = min(ON_BOARDING_YEAR),
    customer_age = as.numeric(format(Sys.Date(), "%Y")) - ON_BOARDING_YEAR,
            
    LOCAL_MARKET_PARTNER = LOCAL_MARKET_PARTNER[which.max(tabulate(match(LOCAL_MARKET_PARTNER,unique(LOCAL_MARKET_PARTNER))))],
    CO2_CUSTOMER =  CO2_CUSTOMER[which.max(tabulate(match(CO2_CUSTOMER, unique(CO2_CUSTOMER))))],
    
    hasOrderedCases = as.integer(case_when((orderedCases)>0 ~1, TRUE ~ 0)),
            
    propCases = sum(orderedCases)/ sum(totalOrdered),
    
    zip_code =  first(ZIP), 
            
    city =  first(City),

    state =  first(`State Name`), 

    region = first(cluster),
             
    distance_from_centroid = first(distance_to_centroid),
    orderedCases = sum(orderedCases),
    orderedGallons = sum(orderedGallons),
    totalOrdered = sum(totalOrdered)) %>% 
   mutate(date = as.Date(paste0((as.integer(sub(" .*", "", Quarter_year.x)) - 1) * 3 + 1, 
                               "/1/", sub(".* ", "", Quarter_year.x)), 
                        format="%m/%d/%Y")) 
  

```


```{r}
plot_data <- BYQUARTER_Customer_No_Retailer %>% 
  group_by(date) %>% 
  summarize(totalOrdered = sum(totalOrdered, na.rm = TRUE),
            totalOrderedCases = sum(orderedCases),
            totalOrderedGallons = sum(orderedGallons)) %>%  # Aggregate properly
    pivot_longer(cols = c(totalOrdered, totalOrderedCases, totalOrderedGallons), 
               names_to = "Metric", values_to = "Value") 

BYQUARTER_Customer_No_Retailer %>% 
  group_by(date) %>% 
  summarize(totalOrdered = sum(totalOrdered, na.rm = TRUE),
            totalOrderedCases = sum(orderedCases),
            totalOrderedGallons = sum(orderedGallons)) %>% 
  ggplot(aes(x = date, y = totalOrdered)) +
  geom_line() +  # Connect points with a line
  geom_point() +  # Show actual data points
  scale_x_date(date_breaks = "1 month", date_labels = "%Y-%m") + 
  scale_y_continuous(labels = label_number(scale = 1e-6, suffix = "M"))+
  labs(x = NULL, y = NULL, title = "Total Ordered")+
  theme_minimal() +
  theme( 
    axis.text.x = element_text(angle = 45, hjust = 1),
    panel.grid = element_blank(), 
    axis.line = element_line(color = "black"),
    panel.background = element_rect(fill = "white", color = NA),
    plot.background = element_rect(fill = "white", color = NA))
```

There is strong ordering trends in Q3
## Non Numeric Exploratory

We want to see if any of the types of businesses will be important 
```{r}
Annual_Customer_ALL %>% 
  ggplot(aes(x = TRADE_CHANNEL)) +
  geom_bar(fill = "steelblue") +
  labs(title = "Customer Count by Trade Channel",
       x = "Trade Channel",
       y = "Number of Customers") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

```{r}
Annual_Customer_ALL %>% 
  ggplot(aes(x = COLD_DRINK_CHANNEL)) +
  geom_bar(fill = "steelblue") +
  labs(title = "Customer Count by Trade Channel",
       x = "Trade Channel",
       y = "Number of Customers") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

The majority are dining customers which might make the model biased in predicting. Trade_Channel creates a lot more levels but again we see an odd distribution. Might not be important


Looking at frequent order type below
```{r}
order_type_summary <- Annual_Customer_ALL |>
  group_by(FREQUENT_ORDER_TYPE) |>
  summarise(count = n(), .groups = "drop") |>
  arrange(desc(count))

# Plot Frequent Order Type Distribution
ggplot(order_type_summary, aes(x = reorder(FREQUENT_ORDER_TYPE, count), y = count)) +
  geom_bar(stat = "identity", position = "stack") +
  labs(title = "Frequent Order Type Breakdown",
       x = "Frequent Order Type",
       y = "Number of Customers",
       fill = "Reached 400 Gallons in 2023") +
  coord_flip() +
  theme_minimal()
```


## Segment Analysis

After some basic modeling, we found that a lot of the non-numeric variables were not statistically significant, or if they were the coefficients were not impactful to a customers future orders, which is what we want to determine in order to determine if we should keep the customer on red truck. 

We created customer segments to identify any differences between customer order/growth groups

We created segments to understand the customers a bit better

### High Volume High Growth Customers
these are customers that order above 400 gallons in both years and have a growth rate over 5%

#### Order distribution of HV customers
```{r}
Annual_Customer_ALL %>% 
  filter(Binning_column == "high volume high growth" | Binning_column == "high volume low growth") %>% 
ggplot( aes(x = Binning_column, y = (total_ordered_2023+total_ordered_2024))) +
  geom_boxplot(fill = "skyblue", color = "darkblue") +
  labs(title = "Average Orders by Customer Segment",
       x = "Customer Segment",
       y = "Average Orders") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```
See a large deviation in order amounts with some very large customers in this group

#### Frequent Order Type
```{r}
HVHG <- Annual_Customer_ALL %>% 
  filter(Binning_column == "high volume high growth" )
  
order_type_summaryHVHG <- HVHG |>
  group_by(FREQUENT_ORDER_TYPE) |>
  summarise(count = n(), .groups = "drop") |>
  arrange(desc(count))

# Plot Frequent Order Type Distribution
ggplot(order_type_summaryHVHG, aes(x = reorder(FREQUENT_ORDER_TYPE, count), y = count)) +
  geom_bar(stat = "identity", position = "stack") +
  labs(title = "Frequent Order Type Breakdown",
       x = "Frequent Order Type",
       y = "Number of Customers",
       fill = "Reached 400 Gallons in 2023") +
  coord_flip() +
  theme_minimal()
  
```


#### Trade Channel
```{r}
HVHG %>% 
  ggplot(aes(x = COLD_DRINK_CHANNEL)) +
  geom_bar(fill = "steelblue") +
  labs(title = "Customer Count by Trade Channel",
       x = "Trade Channel",
       y = "Number of Customers") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


```{r}
HVHG %>% 
  ggplot(aes(x = TRADE_CHANNEL)) +
  geom_bar(fill = "steelblue") +
  labs(title = "Customer Count by Trade Channel",
       x = "Trade Channel",
       y = "Number of Customers") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

#### CO2
```{r}
HVHG %>%
  count(CO2_CUSTOMER) %>%
  mutate(proportion = n / sum(n))
```


#### LMP
```{r}
HVHG %>%
  count(LOCAL_MARKET_PARTNER) %>%
  mutate(proportion = n / sum(n))
```

#### On Boarding Year
```{r}
HVHG %>% 
  ggplot(aes(x = ON_BOARDING_YEAR)) +
  geom_bar(fill = "steelblue") +
  labs(title = "Customer Count by On Boarding Year",
       x = "Trade Channel",
       y = "Number of Customers") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

### High Volume Low Growth
these are customers that order above 400 gallons in both years and have a growth rate less than 5%

#### Frequent Order Type
```{r}
HVLG <- Annual_Customer_ALL %>% 
  filter(Binning_column == "high volume low growth" )
  
order_type_summaryHVLG <- HVLG |>
  group_by(FREQUENT_ORDER_TYPE) |>
  summarise(count = n(), .groups = "drop") |>
  arrange(desc(count))

# Plot Frequent Order Type Distribution
ggplot(order_type_summaryHVLG, aes(x = reorder(FREQUENT_ORDER_TYPE, count), y = count)) +
  geom_bar(stat = "identity", position = "stack") +
  labs(title = "Frequent Order Type Breakdown",
       x = "Frequent Order Type",
       y = "Number of Customers",
       fill = "Reached 400 Gallons in 2023") +
  coord_flip() +
  theme_minimal()
  
```

#### Trade Channel 

```{r}
HVLG %>% 
  ggplot(aes(x = COLD_DRINK_CHANNEL)) +
  geom_bar(fill = "steelblue") +
  labs(title = "Customer Count by Trade Channel",
       x = "Trade Channel",
       y = "Number of Customers") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


```{r}
HVLG %>% 
  ggplot(aes(x = TRADE_CHANNEL)) +
  geom_bar(fill = "steelblue") +
  labs(title = "Customer Count by Trade Channel",
       x = "Trade Channel",
       y = "Number of Customers") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

#### CO2 
```{r}
HVLG %>%
  count(CO2_CUSTOMER) %>%
  mutate(proportion = n / sum(n))
```

#### LMP

```{r}
HVLG %>%
  count(LOCAL_MARKET_PARTNER) %>%
  mutate(proportion = n / sum(n))
```


#### On Boarding Year
```{r}
HVLG %>% 
  ggplot(aes(x = ON_BOARDING_YEAR)) +
  geom_bar(fill = "steelblue") +
  labs(title = "Customer Count by On Boarding Year",
       x = "Trade Channel",
       y = "Number of Customers") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```
Not as many 2024 on boarded customers, but still heavily distributed in the last 5 to 10 years

### Low Volume High Growth
These are customers that ordered less than 400 gallons in each year and have a growth rate of 10% or greater
#### Order distribution for LV customers

```{r}
Annual_Customer_ALL %>% 
  filter(Binning_column == "low volume high growth" | Binning_column == "low volume low growth") %>% 
ggplot( aes(x = Binning_column, y = (total_ordered_2023+total_ordered_2024))) +
  geom_boxplot(fill = "skyblue", color = "darkblue") +
  labs(title = "Average Orders by Customer Segment",
       x = "Customer Segment",
       y = "Average Orders") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```
order volume mean is slightly higher for low growth customers. 

#### Frequent Order Type
```{r}
LVHG <- Annual_Customer_ALL %>% 
  filter(Binning_column == "low volume high growth" )
  
order_type_summaryLVHG <- LVHG |>
  group_by(FREQUENT_ORDER_TYPE) |>
  summarise(count = n(), .groups = "drop") |>
  arrange(desc(count))

# Plot Frequent Order Type Distribution
ggplot(order_type_summaryLVHG, aes(x = reorder(FREQUENT_ORDER_TYPE, count), y = count)) +
  geom_bar(stat = "identity", position = "stack") +
  labs(title = "Frequent Order Type Breakdown",
       x = "Frequent Order Type",
       y = "Number of Customers",
       fill = "Reached 400 Gallons in 2023") +
  coord_flip() +
  theme_minimal()
  
```

No EDI in this group, but minimal in the high volume customer groups

#### Trade Channel 

```{r}
LVHG %>% 
  ggplot(aes(x = COLD_DRINK_CHANNEL)) +
  geom_bar(fill = "steelblue") +
  labs(title = "Customer Count by Trade Channel",
       x = "Trade Channel",
       y = "Number of Customers") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```
maybe slightly less distribution between smaller cold drink channels, but still majority is dining

```{r}
LVHG %>% 
  ggplot(aes(x = TRADE_CHANNEL)) +
  geom_bar(fill = "steelblue") +
  labs(title = "Customer Count by Trade Channel",
       x = "Trade Channel",
       y = "Number of Customers") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

#### CO2 
```{r}
LVHG %>%
  count(CO2_CUSTOMER) %>%
  mutate(proportion = n / sum(n))
```

#### LMP

```{r}
LVHG %>%
  count(LOCAL_MARKET_PARTNER) %>%
  mutate(proportion = n / sum(n))
```
More local market partners in this group. First major difference between customer segments.

#### On Boarding Year
```{r}
LVHG %>% 
  ggplot(aes(x = ON_BOARDING_YEAR)) +
  geom_bar(fill = "steelblue") +
  labs(title = "Customer Count by On Boarding Year",
       x = "Trade Channel",
       y = "Number of Customers") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

Not very many older customers. Still see the skewedness in new customers

### Low Volume Low Growth
These are customers that ordered less than 400 gallons in each year and have a growth rate of less than 10% 


#### Frequent Order Type
```{r}
LVLG <- Annual_Customer_ALL %>% 
  filter(Binning_column == "low volume low growth" )
  
order_type_summaryLVLG <- LVLG |>
  group_by(FREQUENT_ORDER_TYPE) |>
  summarise(count = n(), .groups = "drop") |>
  arrange(desc(count))

# Plot Frequent Order Type Distribution
ggplot(order_type_summaryLVLG, aes(x = reorder(FREQUENT_ORDER_TYPE, count), y = count)) +
  geom_bar(stat = "identity", position = "stack") +
  labs(title = "Frequent Order Type Breakdown",
       x = "Frequent Order Type",
       y = "Number of Customers",
       fill = "Reached 400 Gallons in 2023") +
  coord_flip() +
  theme_minimal()
  
```
Sales rep proves to be dominant across all main customer groups

#### Trade Channel 

```{r}
LVLG %>% 
  ggplot(aes(x = COLD_DRINK_CHANNEL)) +
  geom_bar(fill = "steelblue") +
  labs(title = "Customer Count by Trade Channel",
       x = "Trade Channel",
       y = "Number of Customers") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```
maybe slightly less distribution between smaller cold drink channels, but still majority is dining

```{r}
LVLG %>% 
  ggplot(aes(x = TRADE_CHANNEL)) +
  geom_bar(fill = "steelblue") +
  labs(title = "Customer Count by Trade Channel",
       x = "Trade Channel",
       y = "Number of Customers") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

#### CO2 
```{r}
LVLG %>%
  count(CO2_CUSTOMER) %>%
  mutate(proportion = n / sum(n))
```

#### LMP

```{r}
LVLG %>%
  count(LOCAL_MARKET_PARTNER) %>%
  mutate(proportion = n / sum(n))
```
More local market partners in this group. Possibly show that more Low volme customers are LMP

#### On Boarding Year
```{r}
LVLG %>% 
  ggplot(aes(x = ON_BOARDING_YEAR)) +
  geom_bar(fill = "steelblue") +
  labs(title = "Customer Count by On Boarding Year",
       x = "Trade Channel",
       y = "Number of Customers") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


### Transitionary Growing
These are customers that ordered under threshold in year 1 and ordered above in year 2

#### Order distributions of transitionary customers
```{r}
Annual_Customer_ALL %>% 
  filter(Binning_column == "transtionary growing" | Binning_column == "transitionary declining") %>% 
ggplot( aes(x = Binning_column, y = (total_ordered_2023+total_ordered_2024))) +
  geom_boxplot(fill = "skyblue", color = "darkblue") +
  labs(title = "Average Orders by Customer Segment",
       x = "Customer Segment",
       y = "Average Orders") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

#### Frequent Order Type
```{r}
TG <- Annual_Customer_ALL %>% 
  filter(Binning_column == "transtionary growing" )
  
order_type_summaryTG <- TG |>
  group_by(FREQUENT_ORDER_TYPE) |>
  summarise(count = n(), .groups = "drop") |>
  arrange(desc(count))

# Plot Frequent Order Type Distribution
ggplot(order_type_summaryTG, aes(x = reorder(FREQUENT_ORDER_TYPE, count), y = count)) +
  geom_bar(stat = "identity", position = "stack") +
  labs(title = "Frequent Order Type Breakdown",
       x = "Frequent Order Type",
       y = "Number of Customers",
       fill = "Reached 400 Gallons in 2023") +
  coord_flip() +
  theme_minimal()
  
```
Sales rep proves to be dominant across all main customer groups

#### Trade Channel 

```{r}
TG %>% 
  ggplot(aes(x = COLD_DRINK_CHANNEL)) +
  geom_bar(fill = "steelblue") +
  labs(title = "Customer Count by Trade Channel",
       x = "Trade Channel",
       y = "Number of Customers") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```
maybe slightly less distribution between smaller cold drink channels, but still majority is dining

```{r}
TG %>% 
  ggplot(aes(x = TRADE_CHANNEL)) +
  geom_bar(fill = "steelblue") +
  labs(title = "Customer Count by Trade Channel",
       x = "Trade Channel",
       y = "Number of Customers") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

#### CO2 
```{r}
TG %>%
  count(CO2_CUSTOMER) %>%
  mutate(proportion = n / sum(n))
```

#### LMP

```{r}
TG %>%
  count(LOCAL_MARKET_PARTNER) %>%
  mutate(proportion = n / sum(n))
```
More local market partners in this group as well. On par with low volume customers, which might prove this is important because this group was low volume in year 1 

#### On Boarding Year
```{r}
TG %>% 
  ggplot(aes(x = ON_BOARDING_YEAR)) +
  geom_bar(fill = "steelblue") +
  labs(title = "Customer Count by On Boarding Year",
       x = "Trade Channel",
       y = "Number of Customers") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

A lot of new customers again


### Transitionary Declining
There are customers that had ordered over threshold and declined to below threshold in year 2

#### Frequent Order Type
```{r}
TD <- Annual_Customer_ALL %>% 
  filter(Binning_column == "transitionary declining" )
  
order_type_summaryTD <- TD |>
  group_by(FREQUENT_ORDER_TYPE) |>
  summarise(count = n(), .groups = "drop") |>
  arrange(desc(count))

# Plot Frequent Order Type Distribution
ggplot(order_type_summaryTD, aes(x = reorder(FREQUENT_ORDER_TYPE, count), y = count)) +
  geom_bar(stat = "identity", position = "stack") +
  labs(title = "Frequent Order Type Breakdown",
       x = "Frequent Order Type",
       y = "Number of Customers",
       fill = "Reached 400 Gallons in 2023") +
  coord_flip() +
  theme_minimal()
  
```
Sales rep proves to be dominant across all main customer groups

#### Trade Channel 

```{r}
TD %>% 
  ggplot(aes(x = COLD_DRINK_CHANNEL)) +
  geom_bar(fill = "steelblue") +
  labs(title = "Customer Count by Trade Channel",
       x = "Trade Channel",
       y = "Number of Customers") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```
maybe slightly less distribution between smaller cold drink channels, but still majority is dining

```{r}
TD %>% 
  ggplot(aes(x = TRADE_CHANNEL)) +
  geom_bar(fill = "steelblue") +
  labs(title = "Customer Count by Trade Channel",
       x = "Trade Channel",
       y = "Number of Customers") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

#### CO2 
```{r}
TD %>%
  count(CO2_CUSTOMER) %>%
  mutate(proportion = n / sum(n))
```

#### LMP

```{r}
TD %>%
  count(LOCAL_MARKET_PARTNER) %>%
  mutate(proportion = n / sum(n))
```
More local market partners in this group as well. It looks like only the high volume customers have under 90% LMP

#### On Boarding Year
```{r}
TD %>% 
  ggplot(aes(x = ON_BOARDING_YEAR)) +
  geom_bar(fill = "steelblue") +
  labs(title = "Customer Count by On Boarding Year",
       x = "Trade Channel",
       y = "Number of Customers") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

# Local Market Partner/CO2/Gallons only
In the scope of the project, we were asked to look at LMPs that only order gallons (no cans) and do not order CO2. As shown above, we think there might not be variables provided to us to understand *why* there are differences in ordering between these two groups. But we do perform a t-test and do show that these customers in fact do order less than standard customers. This is likely due to the fact that gallons likely last longer than cans and they are not contractually connected to SWIRE with other contracts through CO2

```{r}
# the "main" data that was used previously : all customer data profile joined with transaction using the Customer Profile Location Data created above.

Customer_Full_Data <- CustomerProfile_Location %>% 
  left_join(aggregated_cost_wide, by = "CUSTOMER_NUMBER") %>% 
  mutate(across(c(orderedCases_2023, orderedCases_2024, orderedGallons_2023, orderedGallons_2024), ~ replace_na(.x, 0)),
         total_ordered = (orderedCases_2024 + orderedGallons_2024 +orderedCases_2023 + orderedGallons_2023),
         total_ordered_2023 = (orderedCases_2023 + orderedGallons_2023),
         total_ordered_2024 = (orderedCases_2024 + orderedGallons_2024)) %>% 
  filter(!(year(FIRST_DELIVERY_DATE) == 2023 & orderedCases_2023 == 0 & orderedGallons_2023 == 0) &
    !(year(FIRST_DELIVERY_DATE) == 2024 & orderedCases_2024 == 0 & orderedGallons_2024 == 0)) %>% 
  filter(!(total_ordered_2023 ==0 & total_ordered_2024 == 0))

Customer_Full_Data <- Customer_Full_Data %>%
  mutate(has_outlet = if_else(!is.na(PRIMARY_GROUP_NUMBER), 1, 0))

outlet_counts <- Customer_Full_Data %>%
  group_by(Entity_ID) %>%
  summarise(number_of_outlets = n_distinct(CUSTOMER_NUMBER), .groups = "drop")

Customer_Full_Data <- Customer_Full_Data %>%
  left_join(outlet_counts, by = "Entity_ID")


# this should not have any issues running on the group set as it is using the same defined variables from above. 

Customer_Full_Data <- Customer_Full_Data |>
  mutate(
    total_ordered = orderedCases_2023 + orderedGallons_2023 + orderedCases_2024 + orderedGallons_2024,
    high_order_volume = if_else(total_ordered >= 400, "High", "Low")
  )


```

```{r}
LMP <- Customer_Full_Data %>% 
  mutate(LMP_Identifier = case_when((LOCAL_MARKET_PARTNER == 1 & CO2_CUSTOMER == 0 & orderedCases_2023==0 & orderedCases_2024 == 0)~"LMP no C02 Fountain Only",(LOCAL_MARKET_PARTNER == 1 & CO2_CUSTOMER == 0 & orderedCases_2023 >= 1 & orderedCases_2024 >= 1)~"LMP No CO2 Cases and Gallons",(LOCAL_MARKET_PARTNER == 1 & CO2_CUSTOMER == 1)~"LMP CO2", TRUE ~ "Not LMP"))
```



```{r}
group1 <- LMP %>% 
  filter(LMP_Identifier == "LMP no C02 Fountain Only") %>% 
  select(total_ordered)

group2 <- LMP %>% 
  filter(LMP_Identifier == "LMP No CO2 Cases and Gallons") %>% 
  select(total_ordered)

t.test(group1, group2, var.equal = FALSE)
```

Customers that order Fountain Only, no CO2 and are a LMP are statistically different than their counterpart. This might be because the way cases are packaged forces the customer to order more of them. CO2 might require a SWIRE only serve coke contract or that they they are serving more soft drinks in general. Where fountain might last longer, this segment of customers might be not reliant on SWIRE to get all of its soda products and are therefore under performing according to SWIREs desired threshold.

# Results
Older customers (pre-2020) are more likely to have met the threshold, suggesting that longer-term customers have more stable purchasing patterns.

Customers with more recent first delivery years (2022-2023) are less likely to have met the threshold, potentially indicating early-stage accounts still growing or accounts that may never scale up.

- Swire may want to track newly onboarded customers to determine early signals of long-term growth vs. stagnation.

- Developing targeted retention strategies for newer accounts could help increase their order volume over time.

Year over year order growth was examined, revealing instnaces of 'infiinte' growth where customers did not have orders in 2023, some of this due to new customers and some due to customer re-engagement.

Co2 customer segmentation found differing behvior between CO2 and on CO2 customers, where a pretty even split of the customers did and do not order CO2, but those that were CO2 customers saw higher median order amounts, but the non CO2 customers saw higher average order amounts, indicating that CO₂ purchases could be a factor in higher-order volume stability. Further segmentation by trade channels, order types, and delivery method (red truck vs. white truck) may provide additional insights into customer retention and profitability.


The analysis focuses on understanding customer ordering behavior, segmentation, and threshold performance. A key threshold of 400 gallons per year is used to determine which customers should remain serviced by Swire’s internal fleet. Many customers fall below this threshold, while a small number account for a large share of total sales, suggesting revenue concentration among high-volume buyers. The log-transformed distributions highlight a mid-tier customer segment that is obscured in the raw data, and there is a significant portion of customers with zero orders, indicating potential churn or re-engagement opportunities.

There does seem to be a lot of distribution issues in the non numeric features which might bias models.

There also does not seem to be very many distinct differences between customer segments, which might make it challenging for a model to predict future customer performance.

## EDA Questions:

- what is the significance on week on the ordering behavior of the customer?

- What is the significance of being a part of an outlet or not on a customer ordering behavior? 

- further defining the target variable, which variable - year over year growth, meeting 400 gallon threshold and order totals will result in the most informative models?

- segmentation of the customers that show growth

- What is the year-over-year growth rate per customer?

- Do certain ordering patterns indicate future growth?

- how does YoverY growth compare as a target variable 
 
- would model performance change with a target variable that is set lower than 800?

- How can cost data further the findings of EDA and modeling? 

### Next Steps:

- Predictive Modeling: Develop a model to forecast which customers will exceed the 400-gallon threshold.


This work was completed and compiled my Imogen Holdsworth and Madalyn Young
